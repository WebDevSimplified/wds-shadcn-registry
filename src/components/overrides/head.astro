---
const { head } = Astro.locals.starlightRoute

// By default, Astro renders the default favicon before the media specific favicons which results in the media specific favicons not being used.
// This code forces the default favicon to only be used when the user has no preference for light or dark mode instead of always being used.
const sortedHead = head.map(h => {
  if (h.tag !== "link") return h
  if (
    typeof h.attrs !== "object" ||
    typeof h.attrs.rel !== "string" ||
    !h.attrs.rel.includes("icon") ||
    h.attrs.media
  ) {
    return h
  }

  return {
    ...h,
    attrs: { ...h.attrs, media: "(prefers-color-scheme: no-preference)" },
  }
})

const ogMetaProperties = new Set([
  "og:image",
  "og:image:secure_url",
  "og:image:width",
  "og:image:height",
])
const ogMetaNames = new Set(["twitter:image"])

const trimmedPath = Astro.url.pathname.replace(/\/$/, "")
const ogImagePath = trimmedPath === "" ? "/og.webp" : `${trimmedPath}/og.webp`
const ogImageUrl = new URL(ogImagePath, Astro.site ?? Astro.url).toString()

const headWithoutStaticOg = sortedHead.filter(item => {
  if (item.tag !== "meta") return true
  const attrs = item.attrs ?? {}
  const property =
    typeof attrs.property === "string" ? attrs.property : undefined
  if (property && ogMetaProperties.has(property)) return false
  const name = typeof attrs.name === "string" ? attrs.name : undefined
  if (name && ogMetaNames.has(name)) return false
  return true
})

const finalHead = headWithoutStaticOg.concat([
  {
    tag: "meta",
    attrs: {
      property: "og:image",
      content: ogImageUrl,
    },
  },
  {
    tag: "meta",
    attrs: {
      property: "og:image:secure_url",
      content: ogImageUrl,
    },
  },
  {
    tag: "meta",
    attrs: {
      property: "og:image:width",
      content: "1200",
    },
  },
  {
    tag: "meta",
    attrs: {
      property: "og:image:height",
      content: "630",
    },
  },
  {
    tag: "meta",
    attrs: {
      name: "twitter:image",
      content: ogImageUrl,
    },
  },
])
---

{
  finalHead.map(({ tag: Tag, attrs, content }) => (
    <Tag {...attrs} set:html={content} />
  ))
}
